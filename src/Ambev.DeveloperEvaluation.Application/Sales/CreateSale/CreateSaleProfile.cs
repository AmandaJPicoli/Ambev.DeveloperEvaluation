using Ambev.DeveloperEvaluation.Domain.Entities;
using AutoMapper;

namespace Ambev.DeveloperEvaluation.Application.Sales.CreateSale
{
    /// <summary>
    /// AutoMapper profile for mapping CreateSaleCommand DTOs to the Sale aggregate and related entities.
    /// Defines the mapping configuration between application layer DTOs and domain entities,
    /// ensuring proper object transformation while maintaining business rule integrity.
    /// </summary>
    public class CreateSaleProfile : Profile
    {
        /// <summary>
        /// Initializes the mappings between CreateSaleCommand and the Sale entity, including items and results.
        /// Configures AutoMapper to use domain entity constructors that enforce business rules.
        /// </summary>
        public CreateSaleProfile()
        {
            // Map CreateSaleCommand to Sale aggregate using domain constructor
            // This ensures that business rules are enforced during entity creation
            CreateMap<CreateSaleCommand, Sale>()
                .ConstructUsing(cmd => new Sale(
                    cmd.SaleNumber,
                    cmd.Date,
                    cmd.CustomerId,
                    cmd.Branch,
                    cmd.Items.Select(i => new SaleItem(i.ProductId, i.Quantity, i.UnitPrice))
                ))
                .ForMember(dest => dest.Id, opt => opt.Ignore()) // ID is generated by domain
                .ForMember(dest => dest.TotalAmount, opt => opt.Ignore()) // Calculated by domain
                .ForMember(dest => dest.Cancelled, opt => opt.Ignore()) // Set by domain
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore()) // Set by domain
                .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore()); // Set by domain

            // Map CreateSaleItemDto to SaleItem using domain constructor
            // This allows the domain entity to apply business rules like discount calculation
            CreateMap<CreateSaleItemDto, SaleItem>()
                .ConstructUsing(dto => new SaleItem(dto.ProductId, dto.Quantity, dto.UnitPrice))
                .ForMember(dest => dest.Discount, opt => opt.Ignore()) // Calculated by domain
                .ForMember(dest => dest.Total, opt => opt.Ignore()); // Calculated by domain

            // Map Sale aggregate to CreateSaleResult for response
            // Uses constructor-based mapping to create immutable result objects
            CreateMap<Sale, CreateSaleResult>()
                .ConstructUsing(sale => new CreateSaleResult(sale.Id, sale.TotalAmount))
                .ForAllMembers(opt => opt.Ignore()); // Constructor handles all mapping
        }
    }
}